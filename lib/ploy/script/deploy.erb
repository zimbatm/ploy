#!/bin/bash
#
# This script is used to deploy an application
#

set -e

DEPLOY_ID="<%= deploy_id %>"
SLUG_URL="<%= slug_url %>"
CONFIG_URL="<%= config_url %>"

APP_ROOT=/mnt/app
DEPLOY_PATH=$APP_ROOT/deploy/$DEPLOY_ID
CURRENT_PATH=$APP_ROOT/current
SLUG_FILE=$DEPLOY_PATH/`basename "$SLUG_URL" | sed 's/\?.*//'`
SLUG_PATH=${SLUG_FILE%.tar.gz}
CONFIG_FILE=$DEPLOY_PATH/`basename "$CONFIG_URL" | sed 's/\?.*//'`

log() {
  echo deploy $DEPLOY_ID: $@
}

# TODO: Use flock to avoid parallel deployments
# TODO: Check that deploy_id are incremental
# TODO: Older deploys cleanup

# Fetch the stuff

mkdir -p $DEPLOY_PATH
cd $DEPLOY_PATH

# Copy itself to the deploy directory for reproductibility
cat $0 > release.sh

log Fetching slug $SLUG_URL
curl -L -o "$SLUG_FILE" "$SLUG_URL"
tar xzvf --no-same-owner "$SLUG_FILE"

log Fetching config $CONFIG_URL
curl -L -o "$CONFIG_FILE" "$CONFIG_URL"

log Install starting
$SLUG_PATH/script/install $CONFIG_FILE

if [ -L $CURRENT_PATH ]; then
  cp -df $CURRENT_PATH $CURRENT_PATH.old
fi

# Atomically link the new release
ln -sf $SLUG_PATH $CURRENT_PATH.new
mv -f -T $CURRENT_PATH.new $CURRENT_PATH

log Running post-install script (if exists)
if [ ! -f $CURRENT_PATH/script/post-install ] || $CURRENT_PATH/script/post-install ; then
  echo Deploy $DEPLOY_ID successful
  if [ -L $CURRENT_PATH.old ]; then
    rm $CURRENT_PATH.old
  fi
else
  echo Deploy $DEPLOY_ID failed
  # Revert link if the post-install didn't work
  if [ -L $CURRENT_PATH.old ]; then
    mv -f -T $CURRENT_PATH.old $CURRENT_PATH
  fi
  false
fi

